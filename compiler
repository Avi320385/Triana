problem:
   Lab work 1: Create a simple Lexical Analyzer using C, C++ or Java programming language.

Sample Input:
int main() { float x = 3. x = 3.14; float y=3.15; float z=x+y; return 0; }


Sample Output:
Tokens Generate by Lexical Analyzer:
Type: KEYWORD, Value: int
Type: IDENTIFIER, Value: main
Type: PUNCTUATOR, Value: (
Type: PUNCTUATOR, Value: )
Type: PUNCTUATOR, Value: {
Type: KEYWORD, Value: float
Type: IDENTIFIER, Value: x
Type: UNKNOWN, Value: =
Type: FLOAT_LITERAL, Value: 3.14
Type: PUNCTUATOR, Value: ;
Type: KEYWORD, Value: float
Type: IDENTIFIER, Value: y
Type: UNKNOWN, Value: =
Type: FLOAT_LITERAL, Value: 3.15
Type: PUNCTUATOR, Value: ;
Type: KEYWORD, Value: float
Type: IDENTIFIER, Value: z
Type: UNKNOWN, Value: =
Type: IDENTIFIER, Value: x
Type: OPERATOR, Value: +
Type: IDENTIFIER, Value: y
Type: PUNCTUATOR, Value: ;
Type: KEYWORD, Value: return
Type: INTEGER_LITERAL, Value: 0
Type: PUNCTUATOR, Value: ;
Type: PUNCTUATOR, Value: }


##solution
     #include <bits/stdc++.h>
using namespace std;

vector<vector<string>> findToken(string s) {
    vector<vector<string>> v;
    string word = "";

    
    set<string> keywords = {"int", "float", "for", "while", "do", "catch", "case", "switch", "auto", "double", 
                            "struct", "break", "else", "long", "return", "continue", "void", "if", "default", 
                            "goto", "const"};
    set<string> operators = {"+", "-", "*", "/", "%", "=", "==", "!=", ">=", "<="};

    for (int i = 0; i < s.size(); i++) {
        char c = s[i];

        
        if (isspace(c) || ispunct(c)) {
            if (!word.empty()) {
                
                if (keywords.count(word)) {
                    v.push_back({"KEYWORD", word});
                } else if (word == "==" || word == "!=" || word == ">=" || word == "<=" || operators.count(word)) {
                    v.push_back({"OPERATOR", word});
                } else if (isdigit(word[0])) {
                    if (word.find('.') != string::npos) {
                        v.push_back({"FLOAT_LITERAL", word});
                    } else {
                        v.push_back({"INTEGER_LITERAL", word});
                    }
                } else if (isalpha(word[0]) || word[0] == '_') {
                    v.push_back({"IDENTIFIER", word});
                } else {
                    v.push_back({"UNKNOWN", word});
                }
                word = ""; 
            }
            
            if (ispunct(c)) {
                string punct(1, c); 
                if (c == '(') {
                    v.push_back({"PUNCTUATOR", punct});
                } else if (c == ')') {
                    v.push_back({"PUNCTUATOR", punct});
                } else if (c == '{') {
                    v.push_back({"PUNCTUATOR", punct});
                } else if (c == '}') {
                    v.push_back({"PUNCTUATOR", punct});
                } else if (c == ';') {
                    v.push_back({"PUNCTUATOR", punct});
                } else if (c == '=') {
                    v.push_back({"PUNCTUATOR", punct});
                } else {
                    v.push_back({"UNKNOWN", punct});
                }
            }
        } else {
            
            word += c;
        }
    }

    
    if (!word.empty()) {
        if (keywords.count(word)) {
            v.push_back({"KEYWORD", word});
        } else if (word == "==" || word == "!=" || word == ">=" || word == "<=" || operators.count(word)) {
            v.push_back({"OPERATOR", word});
        } else if (isdigit(word[0])) {
            if (word.find('.') != string::npos) {
                v.push_back({"FLOAT_LITERAL", word});
            } else {
                v.push_back({"INTEGER_LITERAL", word});
            }
        } else if (isalpha(word[0]) || word[0] == '_') {
            v.push_back({"IDENTIFIER", word});
        } else {
            v.push_back({"UNKNOWN", word});
        }
    }

    return v;
}

int main() {
    string s;
    getline(cin, s);  

    vector<vector<string>> ans = findToken(s);

    cout << "Tokens Generated by Lexical Analyzer:" << endl;


    for (auto x : ans) {
        for (auto r : x) {
            cout << r << " ";
        }
        cout << endl;
    }

    return 0;
}